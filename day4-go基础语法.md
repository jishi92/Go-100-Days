# GO基础语法
## 1，命名和声明

Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。  

大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

和其他语言类型，Go语言中也有一些关键字是不用用于命名的，类似if和switch的关键字有25个；

	break default func interface select
	case defer go map struct
	chan else goto package switch
	const fallthrough if range type
	continue for import return var


Go语言主要有四种类型的声明语句：  

- var:用于声明变量    
- const：用于声明常量  
- type:用于声明类型，多用于结构体  
- func:用于声明函数  

其中，



**变量的声明**分为标准变量声明和简短变量声明：

变量声明的一般语法如下：

	var 变量名字 类型 = 表达式
	eg:var i int = 1
还有一种更简洁的变量声明语法为:=声明，这里省略了var和类型关键字，一般用于函数体内作用域较短的变量声明

	eg：i:=1


**常量声明：**
常量的声明比较简单，和其他语言一样，一般是用一个简单的名称代指不便于使用的字符串或数字。

	eg:const GOLANG100DAY = "希望我可以100天内熟练的掌握go语言"


**类型声明：**

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

	type 类型名字 底层类型


但是如果需要比较两种底层类型一样的变量的话可以通过类型转换来进行比较。类型声明一般出现在包一级。如果是该类型名首字母大写的话在外部包仍可以使用。

	eg:
	type Celsius float64 // 摄氏温度
	type Fahrenheit float64 // 华氏温度

	const (
		AbsoluteZeroC Celsius = -273.15 // 绝对零度
		FreezingC Celsius = 0 // 结冰点温度
		BoilingC Celsius = 100 // 沸水温度
	)



**函数声明：**

一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。由于GO是强类型的语言，所以函数的入参和出参都需要声明其类型。    
如果函数没有返回值，那么返回值列表是省略的。

		eg：摄氏度转华氏度

		func CToF(c Celsius) Fahrenheit { 
			return Fahrenheit(c*9/5 + 32) 
		}


## 2，包和文件

go语言中是没有继承一说的，但可以通过引入包来支持模块化，封装和代码重用。一个包的源码保存在一个或多个go文件中，通常一个文件夹下为同一个包名。

go的每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。

包内可以通过控制方法名的大小写来限定该方法是否可以被外部使用，如果想被外部包使用那么该方法名首字母一定要大写。

如果我想复用别人封装好的一个方法，那么我只要引入他的包即可。

包的引入通过import来实现。
比如我们引入fmt包来进行打印：

	package main
	import (
		"fmt"
	)
	func main() {
		fmt.println("hello go")
	}



## 3，作用域

一个声明语句将程序中的实体和一个名字关联， 比如一个函数或一个变量。 声明语句的作用
域是指源代码中可以有效使用这个名字的范围。

但其实作用域和生命周期不是一个东西。 
声明语句的作用域对应的是一个源代码的文本区域； 它是一个编译时的属性。
一个变量的生命周期是指程序运行时变量存在的有效时间段， 在此时间区域内它可以被程序的其他部分引用； 是一个运行时的概念。  

语法块内的声明只能在语法块内使用，无法被外部使用。所以，一个程序可能包含多个同名的声明， 只要它们在不同的词法域就没有关系。你在外面定义的变量名i和在{}内定义的变量名i完全是两个变量。

当编译器遇到一个名字引用时， 如果它看起来像一个声明， 它首先从最内层的词法域向全局
的作用域查找。 如果查找失败， 则报告**“未声明的名字”**这样的错误。   

如果该名字在内部和外部的块分别声明过， 则内部块的声明首先被找到。 在这种情况下， 内部声明屏蔽了外部同名的声明， 让外部的声明的名字无法被访问：这就是常见的错误变量遮蔽-shodowing。
解决这种错误其实也很简单，只要在内部声明和外部不一样的名称即可。

	eg:
	func main() {
	    n := 0
	    if true {
	        n := 1
	        n++
	    }
	    fmt.Println(n) // 0
	}
	
	
这里因为在if的作用域中对n重新声明了，所以里面的n++对外面的n并不起作用。所以最后结果n=0。

关于变量遮蔽可以看我之前写的一篇文章。

[Golang变量遮蔽——Shadowing。](https://blog.csdn.net/dianxin113/article/details/115009686)